{++

f c i . p a s
Copyright (c) 1997 Alexander Staubo, all rights reserved.

Abstract:

  Translation of fci.h, part of the Cabinet SDK.

Revision history:

  06/07/1997 20:17  alexs  1.0
    Autogenerated by htrans
  26/12/1997 02:55  alexs  1.1
    Fixed declarations of function callbacks, other minor stuff

--}

unit Fci;

{$A+}
{$MINENUMSIZE 4}
{$WEAKPACKAGEUNIT ON}

interface

uses
  SysUtils, Windows;

type
  PVoid = Pointer;
  USHORT = Word;

(*
 *  FCI.H -- File Compression Interface
 *
 *  Copyright (C) Microsoft Corporation 1993-1997
 *  All Rights Reserved.
 *)

type
                                       { f }
  TBYTE = Char;

                                       { b }
  TUINT = Integer;
  
                                       { ui }
  TUSHORT = Smallint;
  
                                       { us }
  TULONG = Longint;
  
                                       { ul }

type
  TCHECKSUM = Longint;
  
                                       { csum }
  TUOFF = Longint;
  
                                       { uoff - uncompressed offset }
  TCOFF = Longint;
  
                                       { coff - cabinet file offset }

{**    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 }

type
  TERF =     
    record
      erfOper : Integer;  // FCI/FDI error code -- see FDIERROR_XXX
        //  and FCIERR_XXX equates for details.
      erfType : Integer;  // Optional error value filled in by FCI/FDI.
        // For FCI, this is usually the C run-time
        // *errno* value.
      fError : Bool;  // TRUE => error present
    end;

                                       { erf }
  PERF = ^TERF;
  
                                       { perf }

const
  CB_MAX_CHUNK = 32768;
  CB_MAX_DISK = $7ffffff;
  CB_MAX_FILENAME = 256;
  CB_MAX_CABINET_NAME = 256;
  CB_MAX_CAB_PATH = 256;
  CB_MAX_DISK_NAME = 256;

{**    tcompXXX - Compression types
 *
 *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER
 *  structures in cabinet files.
 *
 *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM
 *        to provide room for future expansion.  Since this value is stored
 *        in the CFDATA records in the cabinet file, we don't want to
 *        have to change the format for existing compression configurations
 *        if we add new ones in the future.  This will allows us to read
 *        old cabinet files in the future.
 }

type
  TCOMP = Smallint;
  
                                       { tcomp }

const
  tcompMASK_TYPE = $000F;
  tcompTYPE_NONE = $0000;
  tcompTYPE_MSZIP = $0001;
  tcompTYPE_QUANTUM = $0002;
  tcompTYPE_LZX = $0003;
  tcompBAD = $000F;
  tcompMASK_LZX_WINDOW = $1F00;
  tcompLZX_WINDOW_LO = $0F00;
  tcompLZX_WINDOW_HI = $1500;
  tcompSHIFT_LZX_WINDOW = 8;
  tcompMASK_QUANTUM_LEVEL = $00F0;
  tcompQUANTUM_LEVEL_LO = $0010;
  tcompQUANTUM_LEVEL_HI = $0070;
  tcompSHIFT_QUANTUM_LEVEL = 4;
  tcompMASK_QUANTUM_MEM = $1F00;
  tcompQUANTUM_MEM_LO = $0A00;
  tcompQUANTUM_MEM_HI = $1500;
  tcompSHIFT_QUANTUM_MEM = 8;
  tcompMASK_RESERVED = $E000;

{**    FCIERROR - Error codes returned in erf.erfOper field
 *
 }

type
  TFCIERROR =
    (
      FCIERR_NONE,             // No error
      FCIERR_OPEN_SRC,         // Failure opening file to be stored in cabinet
                               //  erf.erfTyp has C run-time *errno* value
      FCIERR_READ_SRC,         // Failure reading file to be stored in cabinet
                               //  erf.erfTyp has C run-time *errno* value
      FCIERR_ALLOC_FAIL,       // Out of memory in FCI
      FCIERR_TEMP_FILE,        // Could not create a temporary file
                               //  erf.erfTyp has C run-time *errno* value
      FCIERR_BAD_COMPR_TYPE,   // Unknown compression type
      FCIERR_CAB_FILE,         // Could not create cabinet file
                               //  erf.erfTyp has C run-time *errno* value
      FCIERR_USER_ABORT,       // Client requested abort
      FCIERR_MCI_FAIL          // Failure compressing data
    );

(*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the filename in the CAB is a UTF string
 *)

const
  _A_NAME_IS_UTF = $80;

(*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the file should be executed after extraction
 *)

const
  _A_EXEC = $40;

{**    HFCI - Handle to an FCI Context
 *
 }

type
  HFCI = PVoid;

{**    CCAB - Current Cabinet
 *
 *  This structure is used for passing in the cabinet parameters to FCI,
 *  and is passed back on certain FCI callbacks to provide cabinet
 *  information to the client.
 }

type
  TCCAB =
    packed record
        // longs first
      cb : TULONG;  // size available for cabinet on this media
      cbFolderThresh : TULONG;  // Thresshold for forcing a new Folder
        // then ints
      cbReserveCFHeader : TUINT;  // Space to reserve in CFHEADER
      cbReserveCFFolder : TUINT;  // Space to reserve in CFFOLDER
      cbReserveCFData : TUINT;  // Space to reserve in CFDATA
      iCab : Integer;  // sequential numbers for cabinets
      iDisk : Integer;  // Disk number
      
      {$IFNDEF REMOVE_CHICAGO_M6_HACK}
      fFailOnIncompressible : Integer;  // TRUE => Fail if a block is incompressible
      {$ENDIF}
      
        //  then shorts
      setID : TUSHORT;  // Cabinet set ID
        // then chars
      szDisk : array[0..256 - 1] of Char;  // current disk name
      szCab : array[0..256 - 1] of Char;  // current cabinet name
      szCabPath : array[0..256 - 1] of Char;  // path for creating cabinet
    end;
    
                                       { ccab }
  PCCAB = ^TCCAB;
  
                                       { pccab }

{**    FNFCIALLOC - Memory Allocation
 *      FNFCIFREE  - Memory Free
 *
 *  These are modeled after the C run-time routines malloc() and free()
 *  FCI expects error handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy the semantics of malloc() and free(),
 *  you can supply any functions you like!
 *
 *  WARNING: You should never assume anything about the sequence of
 *           FNFCIALLOC and FNFCIFREE calls -- incremental releases of
 *           FCI may have radically different numbers of
 *           FNFCIALLOC calls and allocation sizes!
 }

  //** Memory functions for FCI

type
  TFNFCIALLOC = function (cb : TULONG) : PVoid; cdecl;
  PFNFCIALLOC = TFNFCIALLOC;
  
                                       { pfna }
  TFNFCIFREE = function (memory : PVoid) : Pointer; cdecl;
  PFNFCIFREE = TFNFCIFREE;
  
                                       { pfnf }

{**    PFNFCIOPEN  - File I/O callbacks for FCI
 *      PFNFCIREAD
 *      PFNFCIWRITE
 *      PFNFCICLOSE
 *      PFNFCISEEK
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNFCIOPEN oflag
 *  and pmode calls are those defined for _open.  FCI expects error
 *  handling to be identical to these C run-time routines, except that
 *  the value of errno should be returned via *err.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  WARNING: You should never assume you know what file is being
 *           opened at any one point in time!  It is possible
 *           that in a future implementations it may open temporary
 *           files or cabinet files in a different order.
 }

  //** File I/O functions for FCI

type        
  TFNFCIOPEN = function (pszFile : PChar; oflag : Integer; pmode : Integer;
    err : PInteger; pv : Pointer) : Integer; cdecl;
  PFNFCIOPEN = TFNFCIOPEN;

  TFNFCIREAD = function (hf : Integer; memory : PVoid; cb : TUINT; 
    err : PInteger; pv : Pointer) : TUINT; cdecl;
  PFNFCIREAD = TFNFCIREAD;
  
  TFNFCIWRITE = function (hf : Integer; memory : PVoid; cb : TUINT;
    err : PInteger; pv : Pointer) : TUINT; cdecl;
  PFNFCIWRITE = TFNFCIWRITE;
  
  TFNFCICLOSE = function (hf : Integer; err : PInteger; pv : Pointer) : 
    Integer; cdecl;
  PFNFCICLOSE = TFNFCICLOSE;
  
  TFNFCISEEK = function (hf : Integer; dist : Longint; seektype : Integer; 
    err : PInteger; pv : Pointer) : Longint; cdecl;
  PFNFCISEEK = TFNFCISEEK;
  
  TFNFCIDELETE = function (pszFile : PChar; err : PInteger; pv : Pointer) : 
    Integer; cdecl;
  PFNFCIDELETE = TFNFCIDELETE;
  
{**    FNFCIGETNEXTCABINET - Callback used to request new cabinet info
 *
 *  Entry:
 *      pccab     - Points to copy of old ccab structure to modify
 *      cbPrevCab - Estimate of size of previous cabinet
 *      pv        - Has the caller's context pointer
 *
 *  Exit-Success:
 *      returns TRUE;
 *
 *  Exit-Failure:
 *      returns FALSE;
 }

type
  TFNFCIGETNEXTCABINET = function (pccab : PCCAB; cbPrevCab : TULONG; 
    pv : Pointer) : Bool; cdecl;
  PFNFCIGETNEXTCABINET = TFNFCIGETNEXTCABINET;
  
                                       { pfnfcignc }

{**    FNFCIFILEPLACED - Notify FCI client that file was placed
 *
 *  Entry:
 *      pccab         - cabinet structure to fill in, with copy of previous one
 *      pszFile       - name of file, from cabinet
 *      cbFile        - length of file
 *      fContinuation - true if this is a later segment of a continued file
 *      pv            - the context of the client
 *
 *  Exit-Success:
 *      return value anything but -1
 *
 *  Exit-Failure:
 *      return value -1 means to abort
 }

type
  TFNFCIFILEPLACED = function (pccab : PCCAB; pszFile : PChar; 
    cbFile : Longint; fContinuation : Bool; pv : Pointer) : Integer; cdecl;
  PFNFCIFILEPLACED = TFNFCIFILEPLACED;
  
                                       { pfnfcifp }

{**    FNCDIGETOPENINFO - Open source file, get date/time/attribs
 *
 *  Entry:
 *      pszName  -- complete path to filename
 *      pdate    -- location to return FAT-style date code
 *      ptime    -- location to return FAT-style time code
 *      pattribs -- location to return FAT-style attributes
 *      pv       -- client's context
 *
 *  Exit-Success:
 *      Return value is file handle of open file to read
 *
 *  Exit-Failure:
 *      Return value is -1
 }

type
  TFNFCIGETOPENINFO = function (pszName : PChar; var pdate : TUSHORT; 
    var ptime : TUSHORT; var pattribs : TUSHORT; err : PInteger; pv : Pointer) : 
    Integer; cdecl;
  PFNFCIGETOPENINFO = TFNFCIGETOPENINFO;
  
                                       { pfnfcigoi }

{**    FNFCISTATUS - Status/Cabinet Size callback
 *
 *  Entry:
 *      typeStatus == statusFile if compressing a block into a folder
 *                      cb1 = Size of compressed block
 *                      cb2 = Size of uncompressed block
 *
 *      typeStatus == statusFolder if adding a folder to a cabinet
 *                      cb1 = Amount of folder copied to cabinet so far
 *                      cb2 = Total size of folder
 *
 *      typeStatus == statusCabinet if writing out a complete cabinet
 *                      cb1 = Estimated cabinet size that was previously
 *                              passed to fnfciGetNextCabinet().
 *                      cb2 = Actual cabinet size
 *                    NOTE: Return value is desired client size for cabinet
 *                          file.  FCI updates the maximum cabinet size
 *                          remaining using this value.  This allows a client
 *                          to generate multiple cabinets per disk, and have
 *                          FCI limit the size correctly -- the client can do
 *                          cluster size rounding on the cabinet size!
 *                          The client should either return cb2, or round cb2
 *                          up to some larger value and return that.
 *  Exit-Success:
 *      Returns anything other than -1;
 *      NOTE: See statusCabinet for special return values!
 *
 *  Exit-Failure:
 *      Returns -1 to signal that FCI should abort;
 }

const
  statusFile = 0;
  statusFolder = 1;
  statusCabinet = 2;

type
  TFNFCISTATUS = function (typeStatus : TUINT; cb1 : TULONG; cb2 : TULONG; 
    pv : Pointer) : Longint; cdecl;
  PFNFCISTATUS = TFNFCISTATUS;
  
                                       { pfnfcis }

{**    FNFCIGETTEMPFILE - Callback, requests temporary file name
 *
 *  Entry:
 *      pszTempName - Buffer to receive complete tempfile name
 *      cbTempName  - Size of pszTempName buffer
 *
 *  Exit-Success:
 *      return TRUE
 *
 *  Exit-Failure:
 *      return FALSE; could not create tempfile, or buffer too small
 *
 *  Note:
 *      It is conceivable that this function may return a filename
 *      that will already exist by the time it is opened.  For this
 *      reason, the caller should make several attempts to create
 *      temporary files before giving up.
 }

type
  TFNFCIGETTEMPFILE = function (pszTempName : PChar; cbTempName : Integer; 
    pv : Pointer) : Bool; cdecl;
  PFNFCIGETTEMPFILE = TFNFCIGETTEMPFILE;

                                       { pfnfcigtf }

{**    FCICreate -- create an FCI context (an open CAB, an open FOL)
 *
 *  Entry:
 *      perf      - structure where we return error codes
 *      pfnfcifp  - callback to inform caller of eventual dest of files
 *      pfna      - memory allocation function callback
 *      pfnf      - memory free function callback
 *      pfnfcigtf - temp file name generator callback
 *      pccab     - pointer to cabinet/disk name & size structure
 *
 *  Notes:
 *  (1) The alloc/free callbacks must remain valid throughout
 *      the life of the context, up to and including the call to
 *      FCIDestroy.
 *  (2) The perf pointer is stored in the compression context (HCI),
 *      and any errors from subsequent FCI calls are stored in the
 *      erf that was passed in on *this* call.
 *
 *  Exit-Success:
 *      Returns non-NULL handle to an FCI context.
 *
 *  Exit-Failure:
 *      Returns NULL, perf filled in.
 }

  function FCICreate (perf : PERF; pfnfcifp : PFNFCIFILEPLACED; 
    pfna : PFNFCIALLOC; pfnf : PFNFCIFREE; pfnopen : PFNFCIOPEN; 
    pfnread : PFNFCIREAD; pfnwrite : PFNFCIWRITE; pfnclose : PFNFCICLOSE; 
    pfnseek : PFNFCISEEK; pfndelete : PFNFCIDELETE; 
  pfnfcigtf : PFNFCIGETTEMPFILE; pccab : PCCAB; pv : Pointer) : HFCI; cdecl;

{**   FCIAddFile - Add a disk file to a folder/cabinet
 *
 *  Entry:
 *      hfci          - FCI context handle
 *      pszSourceFile - Name of file to add to folder
 *      pszFileName   - Name to store into folder/cabinet
 *      fExecute      - Flag indicating execute on extract
 *      pfn_progress  - Progress callback
 *      pfnfcignc     - GetNextCabinet callback
 *      pfnfcis       - Status callback
 *      pfnfcigoi     - OpenInfo callback
 *      typeCompress  - Type of compression to use for this file
 *      pv            - pointer to caller's internal context
 *
 *  Exit-Success:
 *      returns TRUE
 *
 *  Exit-Failure:
 *      returns FALSE, error filled in
 *    
 *    This is the main function used to add file(s) to a cabinet
 *    or series of cabinets.  If the current file causes the current
 *    folder/cabinet to overflow the disk image currently being built,
 *    the cabinet will be terminated, and a new cabinet/disk name will
 *    be prompted for via a callback.  The pending folder will be trimmed
 *    of the data which has already been generated in the finished cabinet.
 }

  function FCIAddFile (hfci : HFCI; pszSourceFile : PChar; pszFileName : PChar; 
    fExecute : Bool; pfnfcignc : PFNFCIGETNEXTCABINET; pfnfcis : PFNFCISTATUS; 
  pfnfcigoi : PFNFCIGETOPENINFO; typeCompress : TCOMP) : Bool; cdecl;

{**   FCIFlushCabinet - Complete the current cabinet under construction
 *
 *  This will cause the current cabinet (assuming it is not empty) to
 *  be gathered together and written to disk.
 *
 *  Entry:
 *      hfci        - FCI context
 *      fGetNextCab - TRUE  => Call GetNextCab to get continuation info;
 *                    FALSE => Don't call GetNextCab unless this cabinet
 *                             overflows.
 *      pfnfcignc   - callback function to get continuation cabinets
 *      pfnfcis     - callback function for progress reporting
 *      pv          - caller's internal context for callbacks
 *
 *  Exit-Success:
 *      return code TRUE
 *
 *  Exit-Failure:
 *      return code FALSE, error structure filled in
 }

  function FCIFlushCabinet (hfci : HFCI; fGetNextCab : Bool; 
  pfnfcignc : PFNFCIGETNEXTCABINET; pfnfcis : PFNFCISTATUS) : Bool; cdecl;

{**   FCIFlushFolder - Complete the current folder under construction
 *
 *  This will force the termination of the current folder, which may or
 *  may not cause one or more cabinet files to be completed.
 *
 *  Entry:
 *      hfci        - FCI context
 *      GetNextCab  - callback function to get continuation cabinets
 *      pfnProgress - callback function for progress reporting
 *      pv          - caller's internal context for callbacks
 *
 *  Exit-Success:
 *      return code TRUE
 *
 *  Exit-Failure:
 *      return code FALSE, error structure filled in
 }

  function FCIFlushFolder (hfci : HFCI; pfnfcignc : PFNFCIGETNEXTCABINET; 
  pfnfcis : PFNFCISTATUS) : Bool; cdecl;

{**    FCIDestroy - Destroy a FCI context and delete temp files
 *
 *  Entry:
 *      hfci - FCI context
 *
 *  Exit-Success:
 *      return code TRUE
 *
 *  Exit-Failure:
 *      return code FALSE, error structure filled in
 }

function FCIDestroy (hfci : HFCI) : Bool; cdecl;

function CompressionTypeFromTCOMP (tc : TCOMP) : Integer;

function CompressionLevelFromTCOMP (tc : TCOMP) : Integer;

function CompressionMemoryFromTCOMP (tc : TCOMP) : Integer;

function TCOMPfromTypeLevelMemory (t : Integer; l : Integer; m : Integer) : Integer;

function LZXCompressionWindowFromTCOMP (tc : TCOMP) : Integer;

function TCOMPfromLZXWindow (w : Integer) : Integer;

implementation

const
  CabinetDll = 'cabinet.dll';

function FCICreate; external CabinetDll name 'FCICreate';
function FCIAddFile; external CabinetDll name 'FCIAddFile';
function FCIFlushCabinet; external CabinetDll name 'FCIFlushCabinet';
function FCIFlushFolder; external CabinetDll name 'FCIFlushFolder';
function FCIDestroy; external CabinetDll name 'FCIDestroy';

function CompressionTypeFromTCOMP (tc : TCOMP) : Integer;
begin
  Result:=((tc) and $000F);
end;

function CompressionLevelFromTCOMP (tc : TCOMP) : Integer;
begin
  Result:=(((tc) and $00F0) shr 4);
end;

function CompressionMemoryFromTCOMP (tc : TCOMP) : Integer;
begin
  Result:=(((tc) and $1F00) shr 8);
end;

function TCOMPfromTypeLevelMemory (t : Integer; l : Integer; m : Integer) : Integer;
begin
  Result:=(((m) shl 8) or ((l) shl 4) or (t));
end;

function LZXCompressionWindowFromTCOMP (tc : TCOMP) : Integer;
begin
  Result:=(((tc) and $1F00) shr 8);
end;

function TCOMPfromLZXWindow (w : Integer) : Integer;
begin
  Result:=(((w) shl 8) or ($0003));
end;

end.

